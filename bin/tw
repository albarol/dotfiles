#!/usr/bin/env bash

GREEN="\e[32m"
RED="\e[31m"
DIM="\e[2m"
BOLD="\e[1m"
NC="\e[0m"

TASK_PATH=$HOME/.task


function get_script_path() {
    SOURCE="${BASH_SOURCE[0]}"
    while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
        DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
        SOURCE="$(readlink "$SOURCE")"
        [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
    done
    echo "$( cd -P "$( dirname "$SOURCE" )" && pwd )"
}

message_help() {
printf  "\
\$ tw [comand] [arguments]

${BOLD}Usage:${NC}
 tw ${GREEN}timer${NC}     <ID> [minutes]
 tw ${GREEN}stop${NC}
 tw ${GREEN}notebook${NC}  (uuid | id)
 tw ${GREEN}dashboard${NC}
 tw ${GREEN}sync${NC}

${BOLD}Commands:${NC}
 ${GREEN}timer${NC}       Run a task for n minutes.
 ${GREEN}notebook${NC}    Return a notebook for a given.
 ${GREEN}stop${NC}        Stop current running task.
 ${GREEN}dashboard${NC}   Toggle dashboard.
 ${GREEN}sync${NC}        Sync all tasks.

${BOLD}Options:${NC}
${GREEN}--h${NC}elp     Display this help.
"
}

process_timer() {
    if [[ "$#" -lt 1 ]]; then
        printf "${RED}Usage: tw timer 5 25${NC}\n"
        exit 1
    fi

    local INTERVAL=1500
    if [ "$#" -eq 2 ]; then
        INTERVAL=$(expr $2 \* 60)
    fi

    task $1 start &> /dev/null

    if [ $? -ne 0 ]; then
        notify-send "Twtimer" "Task not available." --icon=dialog-error -t 1000 --urgency=critical
        exit 1
    fi

(
    notify-send "Twtimer" "Timer started" --icon=dialog-information -t 1000 --urgency=critical
    sleep $INTERVAL
    notify-send "Twtimer" "Timer stopped" --icon=dialog-information -t 1000 --urgency=critical
    task $1 stop &> /dev/null
    paplay $(get_script_path)/twtimer.ogg
) &
}

process_notebook() {
    if [ "$#" -ne 1 ]; then
        printf "${RED}Usage: tw notebook (uuid | id)${NC}\n"
        exit 1
    fi

    local filename=$(task info $1 |awk '{if($1 == "UUID") print $2}'| tr -d -)

    vim $TASK_PATH/info/$filename
}

process_stop() {
    local current=$(task active |awk 'NR==4 {print $1}')

    if [[ ! -z $current ]]; then
        task $current stop
        ps u |grep "tw timer $current" |awk 'NR==1 {print $2}' |xargs kill
    fi
}

process_dashboard() {
    local processes=$(ps u|grep "tmux -2 attach-session -t twdashboard"|wc -l)

    if [[ "$processes" = "1" ]]; then
	# initialize a tmux session
	tmux new-session -d -s twdashboard -n twindow

	# shows burndown dashboard
	tmux send-keys -t twdashboard:twindow.0 'task burndown.daily' C-j

	# shows calendar
	tmux split-window -h
	tmux send-keys -t 1 'task calendar' C-j

	# shows summary
	tmux split-window -v
	tmux send-keys -t 2 'task ghistory' C-j

	# attach to current window
	tmux -2 attach-session -t twdashboard
    else
	tmux kill-session -t twdashboard
    fi
}

process_sync() {
    cd $TASK_PATH

    local SYNCED_MESSAGE="[Sync] Tasks synced at $(date '+%Y-%m-%d %H:%M')"
    local MSG_COMMIT="$SYNCED_MESSAGE"

    if [[ -n "$1" ]]; then
        MSG_COMMIT=$1
    fi

    if [[ -n $(git status --porcelain) ]]; then
        git add --all
        git commit -m "$MSG_COMMIT" &> /dev/null
    fi
    git pull origin master &> /dev/null
    git push origin master &> /dev/null
    echo $SYNCED_MESSAGE
}

process_commands() {
    local cmd=$1
    shift

    case $cmd in
        timer) process_timer $@;;
        stop) process_stop;;
        notebook) process_notebook $@;;
	dashboard) process_dashboard;;
        sync) process_sync $@;;
        *) message_help;;
    esac
}


if [[ "${@:-1}" = "--help" ]] && [[ "$#" -eq 1 ]]; then
    message_help && exit 0
elif [[ "$#" -ge 1 ]]; then
    process_commands $@
else
    message_help && exit 0
fi

